#!/usr/bin/env python3
# Copyright (c) 2018, Thibault Saunier <tsaunier@igalia.com>
# Copyright (c) 2017, Carlos Soriano <csoriano@gnome.org>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this program; if not, write to the
# Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
# Boston, MA 02110-1301, USA.
# pylint: disable=missing-docstring,invalid-name

import argparse
import configparser
import glob
import json
import os
import shlex
import shutil
import subprocess
import sys
import tempfile
import venv
import re
import fileinput
import pickle

try:
    import yaml
except ModuleNotFoundError:
    print("Yaml not found")
    yaml = None

from urllib.parse import urlparse
from urllib.request import urlretrieve
from enum import Enum

FLATPAK_REQ = "0.10.0"

scriptdir = os.path.abspath(os.path.dirname(__file__))


class Colors(Enum):
    HEADER = "\033[95m"
    OKBLUE = "\033[94m"
    OKGREEN = "\033[92m"
    WARNING = "\033[93m"
    FAIL = "\033[91m"
    ENDC = "\033[0m"


class Console:  # pylint: disable=too-few-public-methods

    quiet = False

    @classmethod
    def message(cls, str_format, *args):
        if cls.quiet:
            return

        if args:
            print(str_format % args)
        else:
            print(str_format)

        # Flush so that messages are printed at the right time
        # as we use many subprocesses.
        sys.stdout.flush()


def load_manifest(manifest_path):
    is_yaml = manifest_path.endswith('.yaml')
    if is_yaml and not yaml:
        print("Trying to load a yaml manifest but python 'yaml' is not installed")

        return False


    with open(manifest_path, "r") as mr:
        if is_yaml:
            manifest = yaml.load(mr)
        else:
            contents = mr.read()
            contents = remove_comments(contents)
            manifest = json.loads(contents)

    return manifest


def expand_manifest(manifest_path, outfile, app_name, app_path):
    """Creates the manifest file."""
    try:
        os.remove(outfile)
    except FileNotFoundError:
        pass

    print("Loading %s" % outfile)
    manifest = load_manifest(manifest_path)
    if not manifest:
        return False

    if "sdk-hash" in manifest:
        del manifest["sdk-hash"]
    if "runtime-hash" in manifest:
        del manifest["runtime-hash"]
    i = 0
    modules = []
    for module in manifest["modules"]:
        submanifest_path = None
        if type(module) is str:
            submanifest_path = os.path.join(os.path.dirname(manifest_path), module)
            module = load_manifest(submanifest_path)

        if isinstance(module, list):
            modules.extend(module)
        else:
            modules.append(module)

    manifest["modules"] = modules
    for module in manifest["modules"]:
        submanifest_path = None
        if module["sources"][0]["type"] == "git":
            if app_name == module["name"]:
                repo = "file://" + app_path
                module["sources"][0]["url"] = repo

        for source in module["sources"]:
            if source["type"] == "patch" or source["type"] == "file":
                if(submanifest_path is not None):
                    source["path"] = os.path.join(os.path.dirname(submanifest_path), source["path"])
                else:
                    source["path"] = os.path.join(os.path.dirname(manifest_path), source["path"])
        i += 1

    with open(outfile, "w") as of:
        print(json.dumps(manifest, indent=4), file=of)

    return True


class FlatpakObject:  # pylint: disable=too-few-public-methods

    def __init__(self, user):
        self.user = user

    def flatpak(self, command, *args, show_output=False, comment=None):
        if comment:
            Console.message(comment)

        command = ["flatpak", command]
        if self.user:
            res = subprocess.check_output(command + ["--help"]).decode("utf-8")
            if "--user" in res:
                command.append("--user")
        command.extend(args)

        if not show_output:
            return subprocess.check_output(command).decode("utf-8")

        return subprocess.check_call(command)


class FlatpakPackages(FlatpakObject):  # pylint: disable=too-few-public-methods

    def __init__(self, repos, user=True):
        FlatpakObject.__init__(self, user=user)

        self.repos = repos

        self.runtimes = self.__detect_runtimes()
        self.apps = self.__detect_apps()
        self.packages = self.runtimes + self.apps

    def __detect_packages(self, *args):
        packs = []
        package_defs = [rd
                        for rd in self.flatpak("list", "-d", *args).split("\n")
                        if rd]
        for package_def in package_defs:
            splited_packaged_def = package_def.split()
            name, arch, branch = splited_packaged_def[0].split("/")

            # If installed from a file, the package is in no repo
            repo_name = splited_packaged_def[1]
            repo = self.repos.repos.get(repo_name)

            packs.append(FlatpakPackage(name, branch, repo, arch))

        return packs

    def __detect_runtimes(self):
        return self.__detect_packages("--runtime")

    def __detect_apps(self):
        return self.__detect_packages()

    def __iter__(self):
        for package in self.packages:
            yield package


class FlatpakRepos(FlatpakObject):

    def __init__(self, user=True):
        FlatpakObject.__init__(self, user=user)
        self.repos = {}
        self.update()

    def update(self):
        self.repos = {}
        remotes = [row
                   for row in self.flatpak("remote-list", "-d").split("\n")
                   if row]
        for repo in remotes:
            for components in [repo.split(" "), repo.split("\t")]:
                if len(components) == 1:
                    components = repo.split("\t")
                name = components[0]
                desc = ""
                url = None
                for elem in components[1:]:
                    if not elem:
                        continue
                    parsed_url = urlparse(elem)
                    if parsed_url.scheme:
                        url = elem
                        break

                    if desc:
                        desc += " "
                    desc += elem

                if url:
                    break

            if not url:
                Console.message("No valid URI found for: %s", repo)
                continue

            self.repos[name] = FlatpakRepo(name, url, desc, repos=self)

        self.packages = FlatpakPackages(self)

    def add(self, repo, override=True):
        same_name = None
        for name, tmprepo in self.repos.items():
            if repo.url == tmprepo.url:
                return tmprepo
            elif repo.name == name:
                same_name = tmprepo

        if same_name:
            if override:
                self.flatpak("remote-modify", repo.name, "--url=" + repo.url,
                             comment="Setting repo %s URL from %s to %s"
                             % (repo.name, same_name.url, repo.url))
                same_name.url = repo.url

                return same_name
            else:
                return None
        else:
            self.flatpak("remote-add", repo.name, "--from", repo.repo_file.name,
                         "--if-not-exists",
                         comment="Adding repo %s" % repo.name)

        repo.repos = self
        return repo


class FlatpakRepo(FlatpakObject):  # pylint: disable=too-few-public-methods

    def __init__(self, name, desc=None, url=None,  # pylint: disable=too-many-arguments
                 repo_file=None, user=True, repos=None):
        FlatpakObject.__init__(self, user=user)

        self.name = name
        self.url = url
        self.desc = desc
        self.repo_file_name = repo_file
        self._repo_file = None
        self.repos = repos
        assert name
        if repo_file and not url:
            repo = configparser.ConfigParser()
            repo.read(self.repo_file.name)
            self.url = repo["Flatpak Repo"]["Url"]
        else:
            assert url

    @property
    def repo_file(self):
        if self._repo_file:
            return self._repo_file

        assert self.repo_file_name
        self._repo_file = tempfile.NamedTemporaryFile(mode="w")
        urlretrieve(self.repo_file_name, self._repo_file.name)

        return self._repo_file


class FlatpakPackage(FlatpakObject):
    """A flatpak app."""

    def __init__(self, name, branch, repo, arch, user=True, hash=None):  # pylint: disable=too-many-arguments
        FlatpakObject.__init__(self, user=user)

        self.name = name
        self.branch = str(branch)
        self.repo = repo
        self.arch = arch
        self.hash = hash

    def __str__(self):
        return "%s/%s/%s %s" % (self.name, self.arch, self.branch, self.repo.name)

    def is_installed(self, branch):
        if not self.repo:
            # Bundle installed from file
            return True

        self.repo.repos.update()
        for package in self.repo.repos.packages:
            if package.name == self.name and \
                    package.branch == branch and \
                    package.arch == self.arch:
                return True

        return False

    def install(self):
        if not self.repo:
            return False

        self.flatpak("install", self.repo.name, self.name, "--reinstall",
                     self.branch, show_output=True,
                     comment="Installing from " + self.repo.name + " " +
                             self.name + " " + self.arch + " " + self.branch)

    def update(self):
        if not self.is_installed(self.branch):
            return self.install()

        extra_args = []
        comment = "Updating %s" % self.name 
        if self.hash:
            extra_args = ["--commit", self.hash]
            comment += " to %s" % self.hash

        self.flatpak("update", self.name, self.branch, show_output=True,
                    *extra_args, comment=comment)

    def run_app(self, *args):
        """Starts the app represented by this instance."""
        self.flatpak("run", "--branch=" + self.branch, self.name, *args,
                     show_output=True,
                     comment="Running %s (%s)" % (self.name, self.branch))


class FlatpakModule(FlatpakObject):

    def __init__(self, flatpak_app, manifest_path, module_name, prefix):
        self.flatpak_app = flatpak_app

        manifest = load_manifest(manifest_path)
        if not manifest:
            exit(1)

        for module in manifest["modules"]:
            if module["name"] == module_name:
                break
        self.prefix = prefix
        self.source_path = module["sources"][0]["url"]
        assert urlparse(self.source_path).scheme == "file"
        self.source_path = urlparse(self.source_path).path
        self.build_system = module.get("buildsystem", "autotools")
        self.config_options = module.get("config-opts", [])
        self.make_args = module.get("make-args", [])
        self.make_install_args = module.get("make-install-args", [])
        self.use_builddir = module.get("builddir", "false")
        self.build_commands = module.get("build-commands", [])

    def install_file(self, **kwargs):
        return "echo \"install %(src)s %(dest)s\"\ninstall -D %(src)s %(dest)s\npatchelf --remove-rpath %(dest)s 2>&1 |grep -v \"not an ELF\" || true\n" % (kwargs)

    def run(self, builddir):
        for command in self.build_commands:
            command = shlex.split(command)
            self.flatpak_app.run_in_sandbox(*command, exit_on_failure=True,
                cwd=self.source_path)

class FlatpakDev:  # pylint: disable=too-many-instance-attributes

    def __init__(self):
        self.sdk_repo = None
        self.runtime = None
        self.locale = None
        self.sdk = None
        self.app = None

        self.packs = []
        self.update = False
        self.args = []
        self.build = False
        self.finish_args = None

        self.gtk = False
        self.wpe = True
        self.clean = False
        self.app_path = os.path.abspath(os.path.join(scriptdir, '../../'))
        self.webkit_path = "/app/webkit"

        self.sdk_branch = None
        self.port = "WPE"
        self.manifest_path = None
        self.name = None
        self.dbus_id = None
        self.build_name = None
        self.cache_path = None
        self.prefix = None
        self.state_path = None
        self.app_module = None
        self.flatpak_default_args = []


    def __strip_dbus_id(self, manifest_path):
        split_path = manifest_path.split("/")
        manifest_name = split_path[len(split_path) - 1].replace(".json", "").replace(".yaml", "")

        return manifest_name

    def check_flatpak(self):
        try:
            output = subprocess.check_output(["flatpak", "--version"])
        except FileNotFoundError:
            Console.message("\n%sYou need to install flatpak >= %s"
                            " to be able to use the '%s' script.\n\n"
                            "You can find some informations about"
                            " how to install it for your distribution at:\n"
                            "    * http://flatpak.org/%s\n", Colors.FAIL,
                            FLATPAK_REQ, sys.argv[0], Colors.ENDC)
            exit(1)

        def comparable_version(version):
            return [int(number) for number in version.split(".")]

        version = output.decode("utf-8").split(" ")[1].strip("\n")
        if comparable_version(version) < comparable_version(FLATPAK_REQ):
            Console.message("\n%sFlatpak %s required but %s found."
                            " Please update and try again%s\n", Colors.FAIL,
                            FLATPAK_REQ, version, Colors.ENDC)
            exit(1)

    def clean_args(self):
        if self.gtk:
            self.port = 'GTK'

        self.manifest_path = os.path.abspath(os.path.join(scriptdir, '../%s/org.webkit.%s.yaml' % (
            self.port.lower(), self.port)))
        self.name = "webkit%s" % self.port
        self.dbus_id = self.__strip_dbus_id(self.manifest_path)
        self.build_name = self.dbus_id + "-generated"
        self.cache_path = os.path.expanduser("~/.cache/flatpak-dev/%s" % self.dbus_id.lower())
        self.prefix = os.path.join(self.app_path, 'WebKitBuild', self.port)
        self.build_path = os.path.join(self.prefix, "Flatpak%s" % self.name)
        self.state_path = os.path.join(self.prefix, "Cache")

        Console.quiet = self.quiet
        self.check_flatpak()

        repos = FlatpakRepos()
        self.sdk_repo = repos.add(
            FlatpakRepo("flathub",
                        url="https://dl.flathub.org/repo/",
                        repo_file="https://dl.flathub.org/repo/flathub.flatpakrepo"))

        manifest = load_manifest(self.manifest_path)
        if not manifest:
            exit(1)

        self.sdk_branch = manifest["runtime-version"]
        self.finish_args = manifest.get("finish-args", [])
        self.finish_args = remove_extension_points(self.finish_args)
        self.dbus_id = manifest["app-id"]
        self.runtime = FlatpakPackage("org.gnome.Platform", self.sdk_branch,
                                      self.sdk_repo, "x86_64",
                                      hash=manifest.get("runtime-hash"))
        self.locale = FlatpakPackage("org.gnome.Platform.Locale",
                                     self.sdk_branch, self.sdk_repo, "x86_64")
        self.sdk = FlatpakPackage("org.gnome.Sdk", self.sdk_branch,
                                  self.sdk_repo, "x86_64",
                                  hash=manifest.get("sdk-hash"))
        self.app = FlatpakPackage(self.dbus_id, "master", None, "x86_64")
        self.packs = [self.runtime, self.locale]

        self.packs.append(self.sdk)
        self.manifest_generated_path = os.path.join(self.prefix,
                                                    self.build_name + ".json")
        self.install_data_file = os.path.join(self.state_path, "install_data")

    def run_in_sandbox(self, *args, exit_on_failure=False, cwd=None):
        with tempfile.NamedTemporaryFile(mode="w") as tmpscript:
            flatpak_command = ["flatpak", "build", "--bin-mount=%s=%s" % (tmpscript.name, "/tmpscript"),
                "--bind-mount=%s=%s" % (self.webkit_path, self.app_path)]

            forwarded = {
                "WEBKIT_TOP_LEVEL": "/app/",
                "LD_LIBRARY_PATH": "/app/lib",
                "TEST_RUNNER_INJECTED_BUNDLE_FILENAME": "/app/lib/libTestRunnerInjectedBundle.so",
            }

            for envvar, value in os.environ.items():
                if envvar in ["WAYLAND_DISPLAY", "DISPLAY", "LANG"]:
                    forwarded[envvar] = value

            for envvar, value in forwarded.items():
                flatpak_command.append("--env=%s=%s" % (envvar, value))

            flatpak_command += self.finish_args + [self.build_path]

            shell_string = ""
            if args:
                if cwd:
                    shell_string = 'cd %s && %s' % (cwd, ' '.join(args))
                else:
                    shell_string = '%s' % (' '.join(args))
            else:
                shell_string = 'echo "\n-> Entering %s environment && bash' % self.name

            print(shell_string, file=tmpscript)
            Console.message("Running in sandbox: %s %s" %(' '.join(flatpak_command), shell_string))

            flatpak_command.extend(['sh', '/tmpscript'])
            try:
                subprocess.check_call(flatpak_command)
            except subprocess.CalledProcessError as e:
                if exit_on_failure:
                    exit(e.returncode)

    def run(self):
        if self.clean:
            if os.path.exists(self.build_path):
                shutil.rmtree(self.build_path)
            if os.path.exists(self.prefix):
                shutil.rmtree(self.prefix)
            if os.path.exists(self.install_data_file):
                os.remove(self.install_data_file)

        if self.update:
            if not self.no_flatpak_update:
                self.update_all()

        self.setup_dev_env()

    def setup_dev_env(self):
        # if os.path.exists(self.prefix) and self.update:
        #     Console.message("Removing prefix %s", self.prefix)
        #     #shutil.rmtree(self.prefix)

        if not os.path.exists(self.prefix) or self.update:
            self.install_all()
            Console.message("Building %s %s and dependencies in %s",
                            self.name, self.branch, self.prefix)

            # Create environment dirs if necessary
            os.makedirs(os.path.dirname(self.manifest_generated_path), exist_ok=True)
            if not expand_manifest(self.manifest_path, self.manifest_generated_path,
                                   self.name, self.webkit_path):
                exit(1)

            builder_args = ["flatpak-builder", "--disable-rofiles-fuse", "--state-dir",
                            self.state_path, "--ccache", self.build_path, "--force-clean",
                            self.manifest_generated_path]
            builder_args.append("--build-only")
            builder_args.append("--stop-at=%s" % self.name)

            try:
                subprocess.check_call(["flatpak-builder", "--version"])
            except FileNotFoundError:
                Console.message("\n%sYou need to install flatpak-builder%s\n",
                                Colors.FAIL, Colors.ENDC)
                exit(1)
            subprocess.check_call(builder_args)

            self.build_app = True


        if self.build_app:
            if not expand_manifest(self.manifest_path, self.manifest_generated_path,
                                   self.name, self.webkit_path):
                exit(1)
            self.app_module = FlatpakModule(self, self.manifest_generated_path, self.name,
                self.prefix)
            self.app_module.run(self.state_path)
        else:
            Console.message("Using %s prefix in %s", self.name, self.prefix)

        if self.run_tests:
            test_launcher = [os.path.join(self.webkit_path, 'Tools/Scripts/run-webkit-tests'), '--debug', '--' + self.port.lower()] + self.args
            self.run_in_sandbox(*test_launcher, exit_on_failure=True)
        elif not self.update and not (self.build_app and not self.args):
            self.run_in_sandbox(*self.args, exit_on_failure=True)

    def install_all(self):
        for package in self.packs:
            if not package.is_installed(self.sdk_branch):
                package.install()

    def update_all(self):
        for m in [self.runtime, self.sdk]:
            m.update()

def remove_extension_points(array):
    result_args = []
    for arg in array:
        if(not arg.startswith('--extension')):
            result_args.append(arg)
    return result_args


def remove_comments(string):
    pattern = r"(\".*?\"|\'.*?\')|(/\*.*?\*/|//[^\r\n]*$)"
    # first group captures quoted strings (double or single)
    # second group captures comments (//single-line or /* multi-line */)
    regex = re.compile(pattern, re.MULTILINE | re.DOTALL)

    def _replacer(match):
        # if the 2nd group (capturing comments) is not None,
        # it means we have captured a non-quoted (real) comment string.
        if match.group(2) is not None:
            return ""  # so we will return empty to remove the comment
        else:  # otherwise, we will return the 1st group
            return match.group(1)  # captured quoted-string
    return regex.sub(_replacer, string)


if __name__ == "__main__":
    flatpak_dev = FlatpakDev()

    parser = argparse.ArgumentParser(prog="flatpak-dev")

    general = parser.add_argument_group("General")
    general.add_argument("--gtk", dest="gtk",
                         action="store_true",
                         help="Build the GTK+ port")
    general.add_argument("--wpe", dest="wpe",
                         action="store_true",
                         help="Build the WPE port",
                         default=True)
    general.add_argument("-nf", "--no-flatpak-update", dest="no_flatpak_update",
                         action="store_true",
                         help="Do not update flaptak runtime/sdk")
    general.add_argument("-u", "--update", dest="update",
                         action="store_true",
                         help="Update the runtime/sdk/app and rebuild the development environment if needed")
    general.add_argument("-b", "--build-app", dest="build_app",
                         action="store_true",
                         help="Force rebuilding the app.")
    general.add_argument("-q", "--quiet", dest="quiet",
                         action="store_true",
                         help="Do not print anything")
    general.add_argument("args",
                         nargs=argparse.REMAINDER,
                         help="Arguments passed when starting %s or, if -d is "
                              "passed, the command to run" % flatpak_dev.name)
    general.add_argument("--name", dest="name",
                         help="The name of the component to develop",
                         default=flatpak_dev.name)

    general.add_argument("-t", "--run-tests", dest="run_tests",
                         action="store_true",
                         help="Run LayoutTests")

    devel = parser.add_argument_group("Development")
    devel.add_argument("--branch", dest="branch",
                       help="The flatpak branch to use (stable, master...)",
                       default="master")
    devel.add_argument("-c", "--clean", dest="clean",
                       action="store_true",
                       help="Clean previous builds and restart from scratch")

    parser.parse_args(namespace=flatpak_dev)
    flatpak_dev.clean_args()
    flatpak_dev.run()